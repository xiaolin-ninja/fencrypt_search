#!/usr/bin/env python3

import getpass
import sys
import argparse
import json
import secrets
import hmac
import hashlib
from Crypto.Cipher import AES
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
import unicodedata
from pathlib import Path

################# ENCRYPTION ################# 

class Encryptor:
	def __init__(self, file, password):
		self.f = file
		self.keys = {}
		self.metadata = {}
		self.password = password

	def encrypt(self):
		try:
			data = self.f.read_text(encoding='utf-8')
			ct = self.__encrypt(data.encode())
			self.__generate_search_terms(data)
		except:
			data = self.f.read_bytes()
			ct = self.__encrypt(data)
			self.metadata["terms"] = []
		write_metadata(self.f, self.metadata)
		write_file(self.f, ct)

	def __encrypt(self, data):
		k1, k2, k3, k4 = self.keys["feistel"]
		mk = self.keys["mac"]
		r1 = ctr_round(data, k1)
		r2 = hmac_round(r1, k2)
		r3 = ctr_round(r2, k3)
		ct = hmac_round(r3, k4)
		self.metadata["mac"] = hmac.new(mk, ct, hashlib.sha256).hexdigest()
		return ct

	def __generate_search_terms(self, data):
		categories = dict.fromkeys({"Lu", "Ll", "Lt", "Lm", "Lo", "Mn", "Nd", "Pc"})
		words = []
		w = ""
		for c in data:
			if unicodedata.category(c) in categories:
				w += c
			else:
				if 4 <= len(w) <= 12 and w not in words:
					words.append(w)
				w = ""
		terms = []
		for w in words:
			w = w.casefold()
			for i in range(4, len(w)):
				terms.append(w[:i]+"*")
			terms.append(w)
		macs = []
		for t in terms:
			mac = mac_str(self.keys["search_terms"], t)
			macs.append(mac)
		self.metadata["terms"] = sorted(macs)

		
################# DECRYPTION ################# 


class Decryptor:
	def __init__(self, file, password):
		self.f = file
		self.keys = {}
		self.metadata = {}
		self.password = password

	def decrypt(self):
		if not validate_password(self):
			raise_err("Incorrect password. No files decrypted." % self.f)
		ct = read_file(self.f)
		if not self.__validate_mac(ct):
			print("MAC mismatch for: %s, file not decrypted." % self.f)
			return
		pt = self.__decrypt(ct)
		write_file(self.f, pt)
		print("Successfully decrypted file: %s" % self.f)
		Path.unlink(get_metadata_fp(self.f))

	def __decrypt(self, data):
		k1, k2, k3, k4 = self.keys["feistel"]
		r1 = hmac_round(data, k4)
		r2 = ctr_round(r1, k3)
		r3 = hmac_round(r2, k2)
		pt = ctr_round(r3, k1)
		return pt

	def __validate_mac(self, ct):
		return self.metadata["mac"] == hmac.new(self.keys["mac"], ct, hashlib.sha256).hexdigest()


################### SEARCH ################### 


class Search:
	def __init__(self):
		self.metadata = {}
		self.keys = {}

	def search(self, s, json_flag):
		self.password = get_password()
		json_output = {}
		results = []
		for p in Path.cwd().glob('.fenc-meta.*'):
			self.metadata = json.loads(p.read_bytes())
			generate_keys(self)
			f = p.name[len(".fenc-meta."):]
			if validate_password(self):
				mac = mac_str(self.keys["search_terms"], s.casefold())
				if mac in self.metadata["terms"]:
					results.append(f)
				json_output[f] = self.keys["master"]
			else:
				print("Incorrect password for file %s." % p.name)
		if args.j:
			print(json_output)
		for r in results:
			print(r)


################# HELPERS ################# 


def parse_flags(args):
	inputs = args.inputs
	json_output = {}

	if args.d and args.e:
		raise_err("Cannot decrypt and encrypt at the same time.")

	if args.s:
		if args.d or args.e:
			raise_err("Cannot decrypt or encrypt and search at the same time.")
		if len(inputs) > 1:
			raise_err("Please enter one search string at a time.")
		s = Search()
		s.search(inputs[0], args.j)
	elif args.e or not (args.d or args.e):
		queue = []
		password = get_password()
		for fp in inputs:
			f = Path(fp)
			validate_file(f)
			e = Encryptor(f, password)
			master_key = generate_keys(e)["master"]
			queue.append(e)
			json_output[fp] = master_key
		if args.j:
			print(json_output, file=sys.stdout)
		for job in queue:
			try:
				job.encrypt()
			except Exception as e:
				print(e)
				continue
	elif args.d:
		invalid_files = []
		queue = []
		password = get_password()
		for fp in inputs:
			f = Path(fp)
			if not get_metadata_fp(f).exists():
				invalid_files.append(fp)
			else:
				d = Decryptor(f, password)
				queue.append(d)
				master_key = generate_keys(d)["master"]
				json_output[fp] = master_key
		if invalid_files:
			raise_err("Metadata not found for: %s. No files decrypted." % invalid_files)
		if args.j:
			print(json_output, file=sys.stdout)
		for job in queue:
			job.decrypt()


def raise_err(err):
	print(err)
	sys.exit(1)


def get_password():
    if sys.stdin.isatty():
    	p = getpass.getpass("password: ")
    	if not p:
    		raise_err("Please enter a password.")
    	return p
    else:
        return sys.stdin.readline().strip()


def validate_password(job):
	return job.metadata["validator"] == job.keys["validator"]


def generate_keys(job):
	if type(job) not in (Encryptor, Search):
		job.metadata = read_metadata(job.f)
	keygen(job)
	return job.keys


def keygen(job):
	if type(job) == Encryptor:
		job.metadata["salt"] = secrets.token_hex(16)
	salt = bytes.fromhex(job.metadata["salt"])
	password = job.password.encode()
	key = hashlib.pbkdf2_hmac('sha256', password, salt, 250000)
	job.keys["master"] = key.hex()
	kdf(job, key)


def kdf(job, key):
	aes_key = key[:16]
	iv = key[16:32]
	ctx = AES.new(aes_key, AES.MODE_ECB)
	validator = ctx.encrypt(iv).hex()
	if type(job) == Encryptor:
		job.metadata["validator"] = validator
	job.keys["validator"] = validator
	job.keys["feistel"] = [ctx.encrypt(increment(iv, i)) for i in range(1,5)] 
	job.keys["mac"] = ctx.encrypt(increment(iv,5))
	job.keys["search_terms"] = ctx.encrypt(increment(iv,6))


def get_validator(key):
	key = bytes.fromhex(key)
	aes_key = key[:16]
	iv = key[16:32]

	ctx = AES.new(aes_key, AES.MODE_ECB)
	return ctx.encrypt(iv).hex()


def increment(b, n):
	b = bytearray(b)
	b[-1] += n
	return bytes(b)


def xor_bytes(bl, b2):
    return bytes([x ^ y for x, y in zip(bl, b2)])


def ctr_round(data, key):
	l = data[:16]
	r = data[16:]
	ks = Cipher(algorithms.AES(key), modes.CTR(l)).encryptor().update(b"\x00" * len(r))
	rout = xor_bytes(ks, r)
	return l + rout


def hmac_round(data, key):
	l = data[:16]
	r = data[16:]
	mac = hmac.new(key, r, hashlib.sha256).digest()
	lout = xor_bytes(l, mac)
	return lout + r


def normalize(s):
	return unicodedata.normalize("NFC", s).encode('utf-8')


def mac_str(k, s):
	s = normalize(s)
	return hmac.new(k, s, hashlib.sha256).hexdigest()


def get_metadata_fp(file):
	return Path(file).parent / (".fenc-meta." + file.name)


def validate_file(f):
	if not f.exists():
		raise_err("File %s does not exist. No files encrypted." % f)
	if get_metadata_fp(f).exists():
		raise_err("File %s is already encrypted. No files encrypted." % f)
	if f.stat().st_size < 32:
		raise_err("File %s is smaller than 32 bytes. No files encrypted." % f)


def read_metadata(file):
	f = get_metadata_fp(file).read_bytes()
	return json.loads(f)


def write_metadata(file, metadata):
	path = get_metadata_fp(file)
	with path.open("w") as o:
		try:
			json.dump(metadata, o, indent=4)
		except:
			Path.unlink(path)
			raise Exception("Metadata write for file: %s unsuccessful. File not encrypted." % file)

def read_file(file):
	return Path(file).read_bytes()


def write_file(file, text):
	return Path(file).write_bytes(text)


############################################# 

if __name__ == '__main__':
	sys.stdout = sys.stderr

	parser = argparse.ArgumentParser(
	description="Encrypts and decrypts binary and text files. "
					"Plaintext search on encrypted files.")
	parser.add_argument('inputs', nargs='+', help='file path or search string')
	parser.add_argument('-d', action="store_true", help='decrypt')
	parser.add_argument('-e', action="store_true", help='encrypt')
	parser.add_argument('-s', action="store_true", help='output to terminal')
	parser.add_argument('-j', action="store_true", help='JSON output')
	args = parser.parse_args()
	parse_flags(parser.parse_args())
