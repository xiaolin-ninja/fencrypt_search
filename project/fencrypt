#!/usr/bin/env python3

import getpass
import sys
import argparse
import json
import os
import secrets
import hmac
import hashlib
import re
from Crypto.Cipher import AES
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
import unicodedata
from pathlib import Path

# -d decryption, followed by file names
# -e encryption, followed by file names
# default to encrypt.
# -s search, only UTF-8 files
# -j json output
# take password input

# error if file smaller than 32 bytes
# PBKDF2 250,000 iterations
# 32 byte output value
# create .fenc-meta.<filename> that contains JSON object with:
## salt, validator, mac, terms <-- JSON list of all search terms, hex encoded.

def run(args):
	validate_flags(args)

################# HELPERS ################# 
# salt, validator, mac, terms
METADATA = {}
KEYS = {}

def log(err):
	sys.stderr.write(err)

def raise_err(err):
	log("[ERROR] " + err + '\n')
	sys.exit(1)

def get_password():
    if sys.stdin.isatty():
        return getpass.getpass("password: ")
    else:
        return sys.stdin.readline().strip()

def keygen(password):
	salt = secrets.token_hex(16)
	METADATA["salt"] = salt
	password = str.encode(password)
	salt = bytes.fromhex(salt)
	
	key = hashlib.pbkdf2_hmac('sha256', password, salt, 250000)
	kdf(key)


def kdf(key):
	aes_key = key[:16]
	iv = key[16:32]

	ctx = AES.new(aes_key, AES.MODE_ECB)
	METADATA["validator"] = ctx.encrypt(iv).hex()

	KEYS["feistel"] = [ctx.encrypt(increment(iv, i)) for i in range(1,5)] 

	mac_key = ctx.encrypt(increment(iv,5))
	KEYS["mac"] = mac_key

	search_key = ctx.encrypt(increment(iv,6))
	KEYS["search_terms"] = search_key


def increment(b, n):
	b = bytearray(b)
	b[-1] += n
	return bytes(b)


def xor_bytes(bl, b2):
    return bytes([x ^ y for x, y in zip(bl, b2)])


def get_metadata_file_path(file):
	return Path(file.name).parent / ("/.fenc-meta." + file.name)


def validate_flags(args):
	if args.d and args.e:
		raise_err("Cannot decrypt and encrypt at the same time.")
	if args.d:
		for file in args.d:
			if not get_metadata_file_path(file).is_file():
				raise_err("Metadata not found for %s. " % file.name + "Program aborted. No files decrypted.")
			decryptor(file)
	if args.e:
		for file in args.e:
			encryptor(file)
	if args.s:
		search(args.s)


def validate_file(f):
	if os.path.getsize(f.name) < 32:
		raise_err("File size must be greater than 32 bytes.")


################# ENCRYPTION ################# 

def encryptor(f):
	validate_file(f)

	try:
		data = open(f.name, encoding='utf-8').read()
		ct = encrypt(data.encode())
		generate_search_terms(data)
	except:
		data = Path(f.name).read_bytes()
		ct = encrypt(data)

	write_file(f, ct)
	write_metadata(f)


def encrypt(data):
	keygen(get_password())

	k1, k2, k3, k4 = KEYS["feistel"]
	mk = KEYS["mac"]
	r1 = ctr_round(data, k1)
	r2 = hmac_round(r1, k2)
	r3 = ctr_round(r2, k3)
	ct = hmac_round(r3, k4)

	mac = hmac.new(mk, ct, hashlib.sha256).hexdigest()
	METADATA["mac"] = mac

	return ct


def generate_search_terms(data):
	categories = ["Lu", "Ll", "Lt", "Lm", "Lo", "Mn", "Nd", "Pc"]
	words = []
	w = ""
	for c in data:
		if unicodedata.category(c) in categories:
			w += c
		else:
			if 4 <= len(w) <= 12 and w not in words:
				words.append(w)
			w = ""

	terms = []
	for w in words:
		for i in range(4, len(w)):
			terms.append(w[:i]+'*')
		terms.append(w)
	terms = normalize(sorted(terms))
	mac = sorted(mac_terms(terms))
	METADATA["terms"] = mac


def normalize(terms):
	return [unicodedata.normalize("NFC", t.casefold()).encode() for t in terms]


def mac_terms(terms):
	return [hmac.new(KEYS["search_terms"], t, hashlib.sha256).hexdigest() for t in terms]

def ctr_round(data, key):
    l = data[:16]
    r = data[16:]
    ks = Cipher(algorithms.AES(key), modes.CTR(l)).encryptor().update(b"\x00" * len(r))
    rout = xor_bytes(ks, r)
    return l + rout


def hmac_round(data, key):
	l = data[:16]
	r = data[16:]
	mac = hmac.new(key, r, hashlib.sha256).digest()
	lout = xor_bytes(l, mac)
	return lout + r


def write_metadata(file):
	with open(get_metadata_file_path(file).name, "w") as o:
		json.dump(METADATA, o, indent=4)


def write_file(file, text):
	return Path(file.name).write_bytes(text)


################# DECRYPTION ################# 

def decryptor(f):
	md = read_metadata(f)
	validate_password(md, f)
	ct = read_ciphertext(f)
	pt = decrypt(ct)
	write_file(f, pt)
	Path.unlink(get_metadata_file_path(f))
	

def decrypt(data):
	k1, k2, k3, k4 = KEYS["feistel"]
	mk = KEYS["mac"]
	r1 = hmac_round(data, k4)
	r2 = ctr_round(r1, k3)
	r3 = hmac_round(r2, k2)
	pt = ctr_round(r3, k1)
	return pt


def validate_password(metadata, f):
	password = str.encode(get_password())
	salt = bytes.fromhex(metadata["salt"])

	key = hashlib.pbkdf2_hmac('sha256', password, salt, 250000)
	kdf(key)

	if metadata["validator"] != METADATA["validator"]:
		raise_err("Incorrect password. Unable to decrypt file: %s." % f.name)


def read_ciphertext(file):
	return Path(file.name).read_bytes()


def read_metadata(file):
	f = Path(get_metadata_file_path(file)).read_bytes()
	return json.loads(f)


################### SEARCH ################### 

def search(s):
	for p in Path.cwd().glob('.fenc-meta.*'):
		m = json.loads(p.read_bytes())
		print(m)

def to_json():
	print("JSON")

############################################# 

if __name__ == '__main__':
	parser = argparse.ArgumentParser()
	# parser.add_argument('filename', metavar='N', type=argparse.FileType('r'))
	parser.add_argument('-d', nargs='+', type=argparse.FileType('r'), help='decrypt')
	parser.add_argument('-e', nargs='+', type=argparse.FileType('r'), help='encrypt')
	parser.add_argument('-s', type=str, help='search')
	parser.add_argument('-j', help='JSON output')
	args = parser.parse_args()
	open_file = args.d
	run(args)


