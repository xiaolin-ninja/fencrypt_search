#!/usr/bin/env python3

import getpass
import sys
import argparse
import json
import secrets
import hmac
import hashlib
import re
from Crypto.Cipher import AES
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
import unicodedata
from pathlib import Path

################# HELPERS ################# 
METADATA = {}
KEYS = {}

def log(err):
	sys.stderr.write(err)

def raise_err(err):
	log("[ERROR] " + err + '\n')
	sys.exit(1)

def get_password():
    if sys.stdin.isatty():
        return getpass.getpass("password: ")
    else:
        return sys.stdin.readline().strip()

def keygen(password):
	salt = secrets.token_hex(16)
	METADATA["salt"] = salt
	password = str.encode(password)
	salt = bytes.fromhex(salt)
	
	key = hashlib.pbkdf2_hmac('sha256', password, salt, 250000)
	kdf(key)


def kdf(key):
	aes_key = key[:16]
	iv = key[16:32]

	ctx = AES.new(aes_key, AES.MODE_ECB)
	METADATA["validator"] = ctx.encrypt(iv).hex()

	KEYS["feistel"] = [ctx.encrypt(increment(iv, i)) for i in range(1,5)] 

	mac_key = ctx.encrypt(increment(iv,5))
	KEYS["mac"] = mac_key

	search_key = ctx.encrypt(increment(iv,6))
	KEYS["search_terms"] = search_key


def increment(b, n):
	b = bytearray(b)
	b[-1] += n
	return bytes(b)


def xor_bytes(bl, b2):
    return bytes([x ^ y for x, y in zip(bl, b2)])


def get_metadata_file_path(file):
	return Path(file).parent / (".fenc-meta." + file)


def parse_flags(args):
	inputs = args.inputs
	if args.d and args.e:
		raise_err("Cannot decrypt and encrypt at the same time.")
	if args.d:
		for file in inputs:
			if not get_metadata_file_path(file).exists():
				raise_err("Metadata not found for %s. Program aborted. No files decrypted." % file)
			decryptor(file)
	if args.e:
		for file in inputs:
			encryptor(file)
	if args.s:
		for file in inputs:
			search(inputs)


def validate_file(f):
	if Path(f).stat().st_size < 32:
		raise_err("File size must be greater than 32 bytes.")


################# ENCRYPTION ################# 

def encryptor(f):
	validate_file(f)

	try:
		data = open(f, encoding='utf-8').read()
		ct = encrypt(data.encode())
		generate_search_terms(data)
	except:
		data = Path(f).read_bytes()
		ct = encrypt(data)

	write_file(f, ct)
	write_metadata(f)


def encrypt(data):
	keygen(get_password())

	k1, k2, k3, k4 = KEYS["feistel"]
	mk = KEYS["mac"]
	r1 = ctr_round(data, k1)
	r2 = hmac_round(r1, k2)
	r3 = ctr_round(r2, k3)
	ct = hmac_round(r3, k4)

	mac = hmac.new(mk, ct, hashlib.sha256).hexdigest()
	METADATA["mac"] = mac

	return ct


def generate_search_terms(data):
	categories = ["Lu", "Ll", "Lt", "Lm", "Lo", "Mn", "Nd", "Pc"]
	words = []
	w = ""
	for c in data:
		if unicodedata.category(c) in categories:
			w += c
		else:
			if 4 <= len(w) <= 12 and w not in words:
				words.append(w)
			w = ""

	terms = []
	for w in words:
		for i in range(4, len(w)):
			terms.append(w[:i]+'*')
		terms.append(w)
	terms = [normalize(t) for t in sorted(terms)]
	macs = [mac_str(t) for t in terms]
	METADATA["terms"] = sorted(macs)


def normalize(s):
	return unicodedata.normalize("NFC", s.casefold()).encode()


def mac_str(s):
	return hmac.new(KEYS["search_terms"], s, hashlib.sha256).hexdigest()


def ctr_round(data, key):
    l = data[:16]
    r = data[16:]
    ks = Cipher(algorithms.AES(key), modes.CTR(l)).encryptor().update(b"\x00" * len(r))
    rout = xor_bytes(ks, r)
    return l + rout


def hmac_round(data, key):
	l = data[:16]
	r = data[16:]
	mac = hmac.new(key, r, hashlib.sha256).digest()
	lout = xor_bytes(l, mac)
	return lout + r


def write_metadata(file):
	with get_metadata_file_path(file).open("w") as o:
		json.dump(METADATA, o, indent=4)


def write_file(file, text):
	return Path(file).write_bytes(text)


################# DECRYPTION ################# 

def decryptor(f):
	md = read_metadata(f)
	if not validate_password(md, get_password()):
		raise_err("Incorrect password. Unable to decrypt file: %s." % f)
	ct = read_ciphertext(f)
	pt = decrypt(ct)
	write_file(f, pt)
	Path.unlink(get_metadata_file_path(f))
	

def decrypt(data):
	k1, k2, k3, k4 = KEYS["feistel"]
	mk = KEYS["mac"]
	r1 = hmac_round(data, k4)
	r2 = ctr_round(r1, k3)
	r3 = hmac_round(r2, k2)
	pt = ctr_round(r3, k1)
	return pt


def validate_password(metadata, password):
	password = str.encode(password)
	salt = bytes.fromhex(metadata["salt"])

	key = hashlib.pbkdf2_hmac('sha256', password, salt, 250000)
	kdf(key)

	return metadata["validator"] == METADATA["validator"]
		

def read_ciphertext(file):
	return Path(file).read_bytes()


def read_metadata(file):
	f = get_metadata_file_path(file).read_bytes()
	return json.loads(f)


################### SEARCH ################### 

def search(s):
	password = get_password()
	for p in Path.cwd().glob('.fenc-meta.*'):
		m = json.loads(p.read_bytes())
		if not validate_password(m, password):
			raise_err("Unable to searchfile %s, password invalid." % p)
		if mac_str(normalize(s)) in m["terms"]:
			print(p.name.removeprefix(".fenc-meta."))


def to_json():
	print("JSON")

############################################# 

if __name__ == '__main__':
	parser = argparse.ArgumentParser(
	description="Encrypts and decrypts binary and text files. "
					"Plaintext search on encrypted files.")
	parser.add_argument('inputs', nargs='+', help='file path or search string')
	parser.add_argument('-d', action="store_true", help='decrypt')
	parser.add_argument('-e', action="store_true", help='encrypt')
	parser.add_argument('-s', action="store_true", help='output to terminal')
	parser.add_argument('-j', action="store_true", help='JSON output')
	args = parser.parse_args()
	parse_flags(args)

