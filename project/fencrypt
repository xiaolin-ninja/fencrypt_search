#!/usr/bin/env python3

import getpass
import sys
import argparse
import json
import secrets
import hmac
import hashlib
import re
from Crypto.Cipher import AES
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
import unicodedata
from pathlib import Path

################# ENCRYPTION ################# 

class Encryptor:
	def __init__(self, file):
		self.f = file
		self.keys = {}
		self.metadata = {}
		self.master_key = None

	def encrypt(self):
		try:
			data = self.f.read_text(encoding='utf-8')
			self.__generate_search_terms(data)
			ct = self.__encrypt(data.encode())
		except:
			data = self.f.read_bytes()
			ct = self.__encrypt(data)
			self.metadata["terms"] = []
		write_metadata(self.f, self.metadata)
		write_file(self.f, ct)

	def get_master_key(self):
		keygen(self)
		return self.master_key

	def __encrypt(self, data):
		k1, k2, k3, k4 = self.keys["feistel"]
		mk = self.keys["mac"]
		r1 = ctr_round(data, k1)
		r2 = hmac_round(r1, k2)
		r3 = ctr_round(r2, k3)
		ct = hmac_round(r3, k4)
		self.metadata["mac"] = hmac.new(mk, ct, hashlib.sha256).hexdigest()
		print("Successfully encrypted file: %s" % self.f)
		return ct


	def __generate_search_terms(self, data):
		categories = dict.fromkeys({"Lu", "Ll", "Lt", "Lm", "Lo", "Mn", "Nd", "Pc"})
		words = []
		w = ""
		for c in data:
			if unicodedata.category(c) in categories:
				w += c
			else:
				if 4 <= len(w) <= 12 and w not in words:
					words.append(w)
				w = ""

		terms = []
		for w in words:
			for i in range(4, len(w)):
				terms.append(w[:i]+'*')
			terms.append(w)

		macs = []
		for t in terms:
			mac = mac_str(self.keys["search_terms"], normalize(t))
			macs.append(mac)

		self.metadata["terms"] = sorted(macs)

################# DECRYPTION ################# 

class Decryptor:
	def __init__(self, file):
		self.f = file
		self.keys = {}
		self.metadata = {}
		self.master_key = None

	def decrypt(self):
		if not validate_password(self):
			raise_err("Incorrect password. Unable to decrypt file: %s." % self.f)
		ct = read_file(self.f)
		pt = self.__decrypt(ct)
		write_file(self.f, pt)
		Path.unlink(get_metadata_fp(self.f))

	def get_master_key(self):
		self.metadata = read_metadata(self.f)
		keygen(self)
		return self.master_key

	def __decrypt(self, data):
		k1, k2, k3, k4 = self.keys["feistel"]
		mk = self.keys["mac"]
		r1 = hmac_round(data, k4)
		r2 = ctr_round(r1, k3)
		r3 = hmac_round(r2, k2)
		pt = ctr_round(r3, k1)
		print("Successfully decrypted file: %s" % self.f)
		return pt

################### SEARCH ################### 

class Search:
	def __init__(self, string):
		self.s = string
		self.metadata = {}
		self.keys = {}

	def search(self):
		for p in Path.cwd().glob('.fenc-meta.*'):
			m = json.loads(p.read_bytes())
			self.metadata["salt"] = m["salt"]
			if not validate_password(self):
				print("Unable to search file %s, password invalid." % p)
			s = normalize(self.s)
			if mac_str(self.keys["search_terms"], s) in m["terms"]:
				print(p.name[len(".fenc-meta."):])


################# HELPERS ################# 


def parse_flags(args):
	inputs = args.inputs
	json_output = {}

	if args.d and args.e:
		raise_err("Cannot decrypt and encrypt at the same time.")

	if args.s:
		if args.d or args.e:
			raise_err("Cannot decrypt or encrypt and search at the same time.")
		if len(inputs) > 1:
			raise_err("Please enter one search string at a time.")
		Search(inputs[0]).search()

	if args.e or not (args.d or args.e):
		queue = []
		for fp in inputs:
			f = Path(fp)
			if get_metadata_fp(f).exists():
				raise_err("File: %s is already encrypted. Program aborted." % f)
			e = Encryptor(f)
			key = e.get_master_key()
			queue.append(e)
			json_output[fp] = key
		if args.j:
			print(json_output, file=sys.stdout)
		for job in queue:
			job.encrypt()

	if args.d:
		invalid_files = []
		queue = []
		for fp in inputs:
			f = Path(fp)
			if not get_metadata_fp(f).exists():
				invalid_files.append(fp)
			else:
				d = Decryptor(f)
				queue.append(d)
				key = d.get_master_key()
				json_output[fp] = key
		if invalid_files:
			raise_err("Metadata not found for: %s. No files decrypted." % invalid_files)
		if args.j:
			print(json_output, file=sys.stdout)
		for job in queue:
			job.decrypt()


def raise_err(err):
	print(err)
	sys.exit(1)


def get_password():
    if sys.stdin.isatty():
    	p = getpass.getpass("password: ")
    	if not p:
    		raise_err("Please enter a password.")
    	return p
    else:
        return sys.stdin.readline().strip()


def validate_password(op):
	return op.metadata["validator"] == get_validator(op.master_key)


def keygen(op):
	salt = op.metadata.get("salt")
	if not salt:
		salt = secrets.token_hex(16)
		op.metadata["salt"] = salt
	salt = bytes.fromhex(salt)
	password = get_password().encode()
	key = hashlib.pbkdf2_hmac('sha256', password, salt, 250000)
	op.master_key = key.hex()
	kdf(op, key)

def kdf(op, key):
	aes_key = key[:16]
	iv = key[16:32]
	ctx = AES.new(aes_key, AES.MODE_ECB)
	op.metadata["validator"] = ctx.encrypt(iv).hex()
	op.keys["feistel"] = [ctx.encrypt(increment(iv, i)) for i in range(1,5)] 
	mac_key = ctx.encrypt(increment(iv,5))
	op.keys["mac"] = mac_key
	search_key = ctx.encrypt(increment(iv,6))
	op.keys["search_terms"] = search_key


def get_validator(key):
	key = bytes.fromhex(key)
	aes_key = key[:16]
	iv = key[16:32]

	ctx = AES.new(aes_key, AES.MODE_ECB)
	return ctx.encrypt(iv).hex()


def increment(b, n):
	b = bytearray(b)
	b[-1] += n
	return bytes(b)


def xor_bytes(bl, b2):
    return bytes([x ^ y for x, y in zip(bl, b2)])


def ctr_round(data, key):
	l = data[:16]
	r = data[16:]
	ks = Cipher(algorithms.AES(key), modes.CTR(l)).encryptor().update(b"\x00" * len(r))
	rout = xor_bytes(ks, r)
	return l + rout


def hmac_round(data, key):
	l = data[:16]
	r = data[16:]
	mac = hmac.new(key, r, hashlib.sha256).digest()
	lout = xor_bytes(l, mac)
	return lout + r


def normalize(s):
	return unicodedata.normalize("NFC", s.casefold()).encode('utf-8')


def mac_str(k, s):
	return hmac.new(k, s, hashlib.sha256).hexdigest()


def get_metadata_fp(file):
	return Path(file).parent / (".fenc-meta." + file.name)


def validate_file(f):
	if not Path(f).exists():
		raise_err("File %s does not exist." % f)
	if Path(f).stat().st_size < 32:
		raise_err("File size must be greater than 32 bytes. File: %s" % f)


def read_metadata(file):
	f = get_metadata_fp(file).read_bytes()
	return json.loads(f)


def write_metadata(file, metadata):
	path = get_metadata_fp(file)
	with path.open("w") as o:
		try:
			json.dump(metadata, o, indent=4)
		except:
			Path.unlink(path)
			raise_err("Metadata write for file: %s unsuccessful. Encryption aborted." % file)


def read_file(file):
	return Path(file).read_bytes()


def write_file(file, text):
	return Path(file).write_bytes(text)


############################################# 

if __name__ == '__main__':
	sys.stdout = sys.stderr

	parser = argparse.ArgumentParser(
	description="Encrypts and decrypts binary and text files. "
					"Plaintext search on encrypted files.")
	parser.add_argument('inputs', nargs='+', help='file path or search string')
	parser.add_argument('-d', action="store_true", help='decrypt')
	parser.add_argument('-e', action="store_true", help='encrypt')
	parser.add_argument('-s', action="store_true", help='output to terminal')
	parser.add_argument('-j', action="store_true", help='JSON output')
	args = parser.parse_args()
	parse_flags(parser.parse_args())
