#!/usr/bin/env python3

import getpass
import sys
import argparse
import json
import secrets
import hmac
import hashlib
import re
from Crypto.Cipher import AES
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
import unicodedata
from pathlib import Path

################# HELPERS ################# 
# METADATA = {}
# KEYS = {}
# json_output = {}

sys.stdout = sys.stderr

def parse_flags(args):
	inputs = args.inputs
	json_flag = False
	json_output = {}

	if args.d and args.e:
		raise_err("Cannot decrypt and encrypt at the same time.")
	if args.j:
		json_flag = True
	if args.s:
		search(inputs[0])

	for fp in inputs:
		f = Path(fp)
		check_file_size(f)

		if args.e:
			if get_metadata_fp(f).exists():
				raise_err("File: %s is already encrypted. Program aborted." % f)
			e = Encryptor(f, json_flag)
			e.encrypt()
			json_output[fp] = e.key
		# if args.d:
		# 	if not get_metadata_file_path(fp).exists():
		# 		raise_err("Metadata not found for file: %s. Program aborted. No files decrypted." % file)
		# 	decryptor(f)
	if json_flag:
		print(json_output)

def raise_err(err):
	print(err)
	sys.exit(1)


def get_password():
    if sys.stdin.isatty():
        p = getpass.getpass("password: ")
        if len(p) < 1:
        	raise_err("Please enter a password.")
        return p
    else:
        return sys.stdin.readline().strip()


def increment(b, n):
	b = bytearray(b)
	b[-1] += n
	return bytes(b)


def xor_bytes(bl, b2):
    return bytes([x ^ y for x, y in zip(bl, b2)])


def get_metadata_fp(file):
	return Path(file).parent / (".fenc-meta." + file.name)


def check_file_size(f):
	if Path(f).stat().st_size < 32:
		raise_err("File size must be greater than 32 bytes.")


################# ENCRYPTION ################# 

class Encryptor:
	def __init__(self, file, json):
		self.f = file
		self.keys = {}
		self.metadata = {}
		self.json_flag = json

	def encrypt(self):
		self.__keygen(get_password())
		try:
			data = self.f.read_text()
			self.__generate_search_terms(data)
			data = data.encode()
		except:
			data = self.f.read_bytes()
		ct = self.__encrypt(data)
		write_metadata(self.f, self.metadata)
		write_file(self.f, ct)


	def __keygen(self, password):
		salt = secrets.token_hex(16)
		self.metadata["salt"] = salt
		password = str.encode(password)
		salt = bytes.fromhex(salt)
		key = hashlib.pbkdf2_hmac('sha256', password, salt, 250000)
		self.key = key.hex()
		self.__kdf(key)


	def __kdf(self, key):
		aes_key = key[:16]
		iv = key[16:32]

		ctx = AES.new(aes_key, AES.MODE_ECB)
		self.metadata["validator"] = ctx.encrypt(iv).hex()
		self.keys["feistel"] = [ctx.encrypt(increment(iv, i)) for i in range(1,5)] 

		mac_key = ctx.encrypt(increment(iv,5))
		self.keys["mac"] = mac_key

		search_key = ctx.encrypt(increment(iv,6))
		self.keys["search_terms"] = search_key


	def __encrypt(self, data):
		k1, k2, k3, k4 = self.keys["feistel"]
		mk = self.keys["mac"]
		r1 = ctr_round(data, k1)
		r2 = hmac_round(r1, k2)
		r3 = ctr_round(r2, k3)
		ct = hmac_round(r3, k4)
		self.metadata["mac"] = hmac.new(mk, ct, hashlib.sha256).hexdigest()
		print("Successfully encrypted file: %s" % self.f)
		return ct


	def __generate_search_terms(self, data):
		categories = dict.fromkeys({"Lu", "Ll", "Lt", "Lm", "Lo", "Mn", "Nd", "Pc"})
		words = []
		w = ""
		for c in data:
			if unicodedata.category(c) in categories:
				w += c
			else:
				if 4 <= len(w) <= 12 and w not in words:
					words.append(w)
				w = ""

		terms = []
		for w in words:
			for i in range(4, len(w)):
				terms.append(w[:i]+'*')
			terms.append(w)
		terms = [normalize(t) for t in sorted(terms)]
		macs = [mac_str(self.keys["mac"], t) for t in terms]
		self.metadata["terms"] = sorted(macs)


def normalize(s):
	return unicodedata.normalize("NFC", s.casefold()).encode()


def mac_str(k, s):
	return hmac.new(k, s, hashlib.sha256).hexdigest()


def ctr_round(data, key):
    l = data[:16]
    r = data[16:]
    ks = Cipher(algorithms.AES(key), modes.CTR(l)).encryptor().update(b"\x00" * len(r))
    rout = xor_bytes(ks, r)
    return l + rout


def hmac_round(data, key):
	l = data[:16]
	r = data[16:]
	mac = hmac.new(key, r, hashlib.sha256).digest()
	lout = xor_bytes(l, mac)
	return lout + r


def write_metadata(file, metadata):
	with get_metadata_fp(file).open("w") as o:
		try:
			json.dump(metadata, o, indent=4)
		except:
			Path.unlink(get_metadata_fp(file))
			raise_err("Metadata write for file: %s unsuccessful. Encryption aborted." % file)


def write_file(file, text):
	return Path(file).write_bytes(text)


################# DECRYPTION ################# 

def decryptor(f):
	md = read_metadata(f)
	if not validate_password(md, get_password()):
		raise_err("Incorrect password. Unable to decrypt file: %s." % f)
	ct = read_ciphertext(f)
	pt = decrypt(ct)
	write_file(f, pt)
	Path.unlink(get_metadata_file_path(f))
	

def decrypt(data):
	k1, k2, k3, k4 = KEYS["feistel"]
	mk = KEYS["mac"]
	r1 = hmac_round(data, k4)
	r2 = ctr_round(r1, k3)
	r3 = hmac_round(r2, k2)
	pt = ctr_round(r3, k1)
	return pt


def validate_password(metadata, password):
	password = str.encode(password)
	salt = bytes.fromhex(metadata["salt"])

	key = hashlib.pbkdf2_hmac('sha256', password, salt, 250000)
	kdf(key)

	return metadata["validator"] == METADATA["validator"]
		

def read_ciphertext(file):
	return Path(file).read_bytes()


def read_metadata(file):
	f = get_metadata_file_path(file).read_bytes()
	return json.loads(f)


################### SEARCH ################### 

def search(s):
	password = get_password()
	for p in Path.cwd().glob('.fenc-meta.*'):
		m = json.loads(p.read_bytes())
		if not validate_password(m, password):
			raise_err("Unable to searchfile %s, password invalid." % p)
		if mac_str(normalize(s)) in m["terms"]:
			print(p.name.removeprefix(".fenc-meta."))


def to_json():
	print("JSON")

############################################# 

if __name__ == '__main__':
	parser = argparse.ArgumentParser(
	description="Encrypts and decrypts binary and text files. "
					"Plaintext search on encrypted files.")
	parser.add_argument('inputs', nargs='+', help='file path or search string')
	parser.add_argument('-d', action="store_true", help='decrypt')
	parser.add_argument('-e', action="store_true", help='encrypt')
	parser.add_argument('-s', action="store_true", help='output to terminal')
	parser.add_argument('-j', action="store_true", help='JSON output')
	args = parser.parse_args()
	parse_flags(args)

